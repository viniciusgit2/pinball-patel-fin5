// Tradu√ß√µes
const translations = {
    pt: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'PONTUA√á√ÉO',
        ballsLabel: 'BOLAS',
        highScoreLabel: 'RECORDE',
        leftFlipperLabel: 'ESQUERDA',
        centerFlipperLabel: 'CENTRO',
        rightFlipperLabel: 'DIREITA',
        startLabel: 'INICIAR',
        instructionsTitle: 'INSTRU√á√ïES',
        inst1: 'Use SETA ESQUERDA, SETA DIREITA e SETA PARA BAIXO para controlar os 3 flippers',
        inst2: 'A bola inicia automaticamente',
        inst3: 'Em dispositivos m√≥veis, toque nos bot√µes na tela',
        inst4: 'Acerte os alvos neon para ganhar pontos',
        inst5: 'Evite perder a bola na parte inferior',
        inst6: 'Voc√™ tem 3 bolas por jogo',
        inst7: 'Use a barra de rolagem para ver mais informa√ß√µes',
        inst8: 'O jogo detecta automaticamente seu idioma baseado na localiza√ß√£o',
        gameOver: 'JOGO ENCERRADO',
        newHighScore: 'NOVO RECORDE!',
        volumeLabel: 'üîä VOLUME:'
    },
    en: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'SCORE',
        ballsLabel: 'BALLS',
        highScoreLabel: 'HIGH SCORE',
        leftFlipperLabel: 'LEFT',
        centerFlipperLabel: 'CENTER',
        rightFlipperLabel: 'RIGHT',
        startLabel: 'START',
        instructionsTitle: 'INSTRUCTIONS',
        inst1: 'Use LEFT, RIGHT and DOWN ARROW keys to control the 3 flippers',
        inst2: 'Ball launches automatically',
        inst3: 'On mobile devices, tap the on-screen buttons',
        inst4: 'Hit neon targets to score points',
        inst5: 'Avoid losing the ball at the bottom',
        inst6: 'You have 3 balls per game',
        inst7: 'Use the scrollbar to see more information',
        inst8: 'The game automatically detects your language based on location',
        gameOver: 'GAME OVER',
        newHighScore: 'NEW HIGH SCORE!',
        volumeLabel: 'üîä VOLUME:'
    },
    es: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'PUNTUACI√ìN',
        ballsLabel: 'BOLAS',
        highScoreLabel: 'R√âCORD',
        leftFlipperLabel: 'IZQUIERDA',
        centerFlipperLabel: 'CENTRO',
        rightFlipperLabel: 'DERECHA',
        startLabel: 'INICIAR',
        instructionsTitle: 'INSTRUCCIONES',
        inst1: 'Use las teclas FLECHA IZQUIERDA, FLECHA DERECHA y FLECHA ABAJO para controlar los 3 flippers',
        inst2: 'La bola se inicia autom√°ticamente',
        inst3: 'En dispositivos m√≥viles, toque los botones en la pantalla',
        inst4: 'Golpee los objetivos ne√≥n para ganar puntos',
        inst5: 'Evite perder la bola en la parte inferior',
        inst6: 'Tiene 3 bolas por juego',
        inst7: 'Use la barra de desplazamiento para ver m√°s informaci√≥n',
        inst8: 'El juego detecta autom√°ticamente su idioma seg√∫n la ubicaci√≥n',
        gameOver: 'JUEGO TERMINADO',
        newHighScore: '¬°NUEVO R√âCORD!',
        volumeLabel: 'üîä VOLUMEN:'
    },
    fr: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'SCORE',
        ballsLabel: 'BALLES',
        highScoreLabel: 'MEILLEUR SCORE',
        leftFlipperLabel: 'GAUCHE',
        centerFlipperLabel: 'CENTRE',
        rightFlipperLabel: 'DROITE',
        startLabel: 'D√âMARRER',
        instructionsTitle: 'INSTRUCTIONS',
        inst1: 'Utilisez les touches FL√àCHE GAUCHE, FL√àCHE DROITE et FL√àCHE BAS pour contr√¥ler les 3 flippers',
        inst2: 'La balle se lance automatiquement',
        inst3: 'Sur les appareils mobiles, appuyez sur les boutons √† l\'√©cran',
        inst4: 'Frappez les cibles n√©on pour marquer des points',
        inst5: '√âvitez de perdre la balle en bas',
        inst6: 'Vous avez 3 balles par partie',
        inst7: 'Utilisez la barre de d√©filement pour voir plus d\'informations',
        inst8: 'Le jeu d√©tecte automatiquement votre langue en fonction de votre localisation',
        gameOver: 'PARTIE TERMIN√âE',
        newHighScore: 'NOUVEAU RECORD!',
        volumeLabel: 'üîä VOLUME:'
    },
    de: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'PUNKTZAHL',
        ballsLabel: 'B√ÑLLE',
        highScoreLabel: 'H√ñCHSTPUNKTZAHL',
        leftFlipperLabel: 'LINKS',
        centerFlipperLabel: 'MITTE',
        rightFlipperLabel: 'RECHTS',
        startLabel: 'START',
        instructionsTitle: 'ANLEITUNG',
        inst1: 'Verwenden Sie die PFEIL LINKS, PFEIL RECHTS und PFEIL UNTEN Tasten um die 3 Flipper zu steuern',
        inst2: 'Der Ball startet automatisch',
        inst3: 'Auf mobilen Ger√§ten tippen Sie auf die Bildschirmtasten',
        inst4: 'Treffen Sie Neon-Ziele um Punkte zu erzielen',
        inst5: 'Vermeiden Sie es den Ball unten zu verlieren',
        inst6: 'Sie haben 3 B√§lle pro Spiel',
        inst7: 'Verwenden Sie die Scrollleiste um weitere Informationen zu sehen',
        inst8: 'Das Spiel erkennt automatisch Ihre Sprache basierend auf dem Standort',
        gameOver: 'SPIEL VORBEI',
        newHighScore: 'NEUER REKORD!',
        volumeLabel: 'üîä LAUTST√ÑRKE:'
    },
    it: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'PUNTEGGIO',
        ballsLabel: 'PALLE',
        highScoreLabel: 'PUNTEGGIO MASSIMO',
        leftFlipperLabel: 'SINISTRA',
        centerFlipperLabel: 'CENTRO',
        rightFlipperLabel: 'DESTRA',
        startLabel: 'INIZIA',
        instructionsTitle: 'ISTRUZIONI',
        inst1: 'Usa i tasti FRECCIA SINISTRA, FRECCIA DESTRA e FRECCIA GI√ô per controllare i 3 flipper',
        inst2: 'La palla si avvia automaticamente',
        inst3: 'Sui dispositivi mobili, tocca i pulsanti sullo schermo',
        inst4: 'Colpisci i bersagli al neon per segnare punti',
        inst5: 'Evita di perdere la palla in basso',
        inst6: 'Hai 3 palle per partita',
        inst7: 'Usa la barra di scorrimento per vedere pi√π informazioni',
        inst8: 'Il gioco rileva automaticamente la tua lingua in base alla posizione',
        gameOver: 'PARTITA FINITA',
        newHighScore: 'NUOVO RECORD!',
        volumeLabel: 'üîä VOLUME:'
    },
    ja: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: '„Çπ„Ç≥„Ç¢',
        ballsLabel: '„Éú„Éº„É´',
        highScoreLabel: '„Éè„Ç§„Çπ„Ç≥„Ç¢',
        leftFlipperLabel: 'Â∑¶',
        centerFlipperLabel: '‰∏≠Â§Æ',
        rightFlipperLabel: 'Âè≥',
        startLabel: '„Çπ„Çø„Éº„Éà',
        instructionsTitle: 'Ë™¨Êòé',
        inst1: 'Â∑¶Áü¢Âç∞„ÄÅÂè≥Áü¢Âç∞„ÄÅ‰∏ãÁü¢Âç∞„Ç≠„Éº„Çí‰ΩøÁî®„Åó„Å¶3„Å§„ÅÆ„Éï„É™„ÉÉ„Éë„Éº„ÇíÂà∂Âæ°„Åó„Åæ„Åô',
        inst2: '„Éú„Éº„É´„ÅØËá™ÂãïÁöÑ„Å´Áô∫Â∞Ñ„Åï„Çå„Åæ„Åô',
        inst3: '„É¢„Éê„Ç§„É´„Éá„Éê„Ç§„Çπ„Åß„ÅØ„ÄÅÁîªÈù¢‰∏ä„ÅÆ„Éú„Çø„É≥„Çí„Çø„ÉÉ„Éó„Åó„Åæ„Åô',
        inst4: '„Éç„Ç™„É≥„Çø„Éº„Ç≤„ÉÉ„Éà„Å´ÂΩì„Å¶„Å¶„Éù„Ç§„É≥„Éà„ÇíÁç≤Âæó„Åó„Åæ„Åô',
        inst5: '‰∏ãÈÉ®„Åß„Éú„Éº„É´„ÇíÂ§±„Çè„Å™„ÅÑ„Çà„ÅÜ„Å´„Åó„Åæ„Åô',
        inst6: '„Ç≤„Éº„É†„Åî„Å®„Å´3„Å§„ÅÆ„Éú„Éº„É´„Åå„ÅÇ„Çä„Åæ„Åô',
        inst7: '„Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„Çí‰ΩøÁî®„Åó„Å¶Ë©≥Á¥∞ÊÉÖÂ†±„ÇíË°®Á§∫„Åó„Åæ„Åô',
        inst8: '„Ç≤„Éº„É†„ÅØ‰ΩçÁΩÆÊÉÖÂ†±„Å´Âü∫„Å•„ÅÑ„Å¶Ëá™ÂãïÁöÑ„Å´Ë®ÄË™û„ÇíÊ§úÂá∫„Åó„Åæ„Åô',
        gameOver: '„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº',
        newHighScore: 'Êñ∞Ë®òÈå≤ÔºÅ',
        volumeLabel: 'üîä Èü≥Èáè:'
    },
    zh: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'ÂàÜÊï∞',
        ballsLabel: 'ÁêÉ',
        highScoreLabel: 'ÊúÄÈ´òÂàÜ',
        leftFlipperLabel: 'Â∑¶',
        centerFlipperLabel: '‰∏≠',
        rightFlipperLabel: 'Âè≥',
        startLabel: 'ÂºÄÂßã',
        instructionsTitle: 'ËØ¥Êòé',
        inst1: '‰ΩøÁî®Â∑¶ÁÆ≠Â§¥„ÄÅÂè≥ÁÆ≠Â§¥Âíå‰∏ãÁÆ≠Â§¥ÈîÆÊéßÂà∂3‰∏™Êå°Êùø',
        inst2: 'ÁêÉ‰ºöËá™Âä®ÂèëÂ∞Ñ',
        inst3: 'Âú®ÁßªÂä®ËÆæÂ§á‰∏äÔºåÁÇπÂáªÂ±èÂπïÊåâÈíÆ',
        inst4: 'Âáª‰∏≠ÈúìËôπÁõÆÊ†áËé∑ÂæóÂàÜÊï∞',
        inst5: 'ÈÅøÂÖçÂú®Â∫ïÈÉ®Â§±ÂéªÁêÉ',
        inst6: 'ÊØèÂ±ÄÊ∏∏ÊàèÊúâ3‰∏™ÁêÉ',
        inst7: '‰ΩøÁî®ÊªöÂä®Êù°Êü•ÁúãÊõ¥Â§ö‰ø°ÊÅØ',
        inst8: 'Ê∏∏Êàè‰ºöÊ†πÊçÆ‰ΩçÁΩÆËá™Âä®Ê£ÄÊµãÊÇ®ÁöÑËØ≠Ë®Ä',
        gameOver: 'Ê∏∏ÊàèÁªìÊùü',
        newHighScore: 'Êñ∞Á∫™ÂΩïÔºÅ',
        volumeLabel: 'üîä Èü≥Èáè:'
    },
    ru: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: '–°–ß–Å–¢',
        ballsLabel: '–®–ê–†–´',
        highScoreLabel: '–†–ï–ö–û–†–î',
        leftFlipperLabel: '–õ–ï–í–û',
        centerFlipperLabel: '–¶–ï–ù–¢–†',
        rightFlipperLabel: '–ü–†–ê–í–û',
        startLabel: '–°–¢–ê–†–¢',
        instructionsTitle: '–ò–ù–°–¢–†–£–ö–¶–ò–ò',
        inst1: '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª–∞–≤–∏—à–∏ –°–¢–†–ï–õ–ö–ê –í–õ–ï–í–û, –°–¢–†–ï–õ–ö–ê –í–ü–†–ê–í–û –∏ –°–¢–†–ï–õ–ö–ê –í–ù–ò–ó –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è 3 —Ñ–ª–∏–ø–ø–µ—Ä–∞–º–∏',
        inst2: '–ú—è—á –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏',
        inst3: '–ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö –Ω–∞–∂–∏–º–∞–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ',
        inst4: '–ü–æ–ø–∞–¥–∞–π—Ç–µ –≤ –Ω–µ–æ–Ω–æ–≤—ã–µ —Ü–µ–ª–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—á–∫–æ–≤',
        inst5: '–ò–∑–±–µ–≥–∞–π—Ç–µ –ø–æ—Ç–µ—Ä–∏ —à–∞—Ä–∞ –≤–Ω–∏–∑—É',
        inst6: '–£ –≤–∞—Å –µ—Å—Ç—å 3 —à–∞—Ä–∞ –Ω–∞ –∏–≥—Ä—É',
        inst7: '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–ª–æ—Å—É –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏',
        inst8: '–ò–≥—Ä–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≤–∞—à —è–∑—ã–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è',
        gameOver: '–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê',
        newHighScore: '–ù–û–í–´–ô –†–ï–ö–û–†–î!',
        volumeLabel: 'üîä –ì–†–û–ú–ö–û–°–¢–¨:'
    },
    ar: {
        title: 'NEON SKULL PINBALL',
        scoreLabel: 'ÿßŸÑŸÜŸÇÿßÿ∑',
        ballsLabel: 'ÿßŸÑŸÉÿ±ÿßÿ™',
        highScoreLabel: 'ÿ£ÿπŸÑŸâ ŸÜŸÇÿßÿ∑',
        leftFlipperLabel: 'Ÿäÿ≥ÿßÿ±',
        centerFlipperLabel: 'Ÿàÿ≥ÿ∑',
        rightFlipperLabel: 'ŸäŸÖŸäŸÜ',
        startLabel: 'ÿßÿ®ÿØÿ£',
        instructionsTitle: 'ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™',
        inst1: 'ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿ≥ŸáŸÖ ÿßŸÑÿ£Ÿäÿ≥ÿ± ŸàÿßŸÑÿ≥ŸáŸÖ ÿßŸÑÿ£ŸäŸÖŸÜ ŸàÿßŸÑÿ≥ŸáŸÖ ÿßŸÑÿ≥ŸÅŸÑŸä ŸÑŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿßŸÑÿ≤ÿπÿßŸÜŸÅ ÿßŸÑÿ´ŸÑÿßÿ´ÿ©',
        inst2: 'ÿ™Ÿèÿ∑ŸÑŸÇ ÿßŸÑŸÉÿ±ÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß',
        inst3: 'ÿπŸÑŸâ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ© ÿßŸÑŸÖÿ≠ŸÖŸàŸÑÿ©ÿå ÿßŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ¥ÿßÿ¥ÿ©',
        inst4: 'ÿßÿµÿ∑ÿØŸÖ ÿ®ÿßŸÑÿ£ŸáÿØÿßŸÅ ÿßŸÑŸÜŸäŸàŸÜ ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÜŸÇÿßÿ∑',
        inst5: 'ÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑŸÉÿ±ÿ© ŸÅŸä ÿßŸÑÿ£ÿ≥ŸÅŸÑ',
        inst6: 'ŸÑÿØŸäŸÉ 3 ŸÉÿ±ÿßÿ™ ŸÑŸÉŸÑ ŸÑÿπÿ®ÿ©',
        inst7: 'ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÖÿ±Ÿäÿ± ŸÑÿ±ÿ§Ÿäÿ© ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™',
        inst8: 'ÿ™ŸÉÿ™ÿ¥ŸÅ ÿßŸÑŸÑÿπÿ®ÿ© ŸÑÿ∫ÿ™ŸÉ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ',
        gameOver: 'ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©',
        newHighScore: 'ÿ±ŸÇŸÖ ŸÇŸäÿßÿ≥Ÿä ÿ¨ÿØŸäÿØ!',
        volumeLabel: 'üîä ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™:'
    }
};

// Sistema de √Åudio
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
let masterVolume = 0.7;

// M√∫sica de Fundo
const backgroundMusic = document.getElementById('backgroundMusic');
backgroundMusic.volume = masterVolume;

// Fun√ß√µes de som sintetizado
function playSound(type) {
    if (!audioCtx) return;
    
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;
    
    switch(type) {
        case 'flipper':
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(150, now);
            oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gainNode.gain.setValueAtTime(masterVolume * 0.3, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            oscillator.start(now);
            oscillator.stop(now + 0.1);
            break;
            
        case 'hit':
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, now);
            oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.15);
            gainNode.gain.setValueAtTime(masterVolume * 0.4, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            oscillator.start(now);
            oscillator.stop(now + 0.15);
            break;
            
        case 'launch':
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(100, now);
            oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.2);
            gainNode.gain.setValueAtTime(masterVolume * 0.4, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            oscillator.start(now);
            oscillator.stop(now + 0.2);
            break;

            
        case 'wall':
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(200, now);
            gainNode.gain.setValueAtTime(masterVolume * 0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            oscillator.start(now);
            oscillator.stop(now + 0.05);
            break;
            
        case 'lose':
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(400, now);
            oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.5);
            gainNode.gain.setValueAtTime(masterVolume * 0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            oscillator.start(now);
            oscillator.stop(now + 0.5);
            break;
            
        case 'gameOver':
            // Som de game over (sequ√™ncia descendente)
            const freqs = [400, 350, 300, 250, 200];
            freqs.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.15);
                gain.gain.setValueAtTime(masterVolume * 0.3, now + i * 0.15);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.15);
                osc.start(now + i * 0.15);
                osc.stop(now + i * 0.15 + 0.15);
            });
            return;
            
        case 'highScore':
            // Som de novo recorde (sequ√™ncia ascendente)
            const notesUp = [523, 587, 659, 784, 880];
            notesUp.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, now + i * 0.1);
                gain.gain.setValueAtTime(masterVolume * 0.4, now + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.2);
            });
            return;
    }
}

// Controle de volume
const volumeControl = document.getElementById('volumeControl');
const volumeValue = document.getElementById('volumeValue');

volumeControl.addEventListener('input', (e) => {
    masterVolume = e.target.value / 100;
    volumeValue.textContent = e.target.value + '%';
    backgroundMusic.volume = masterVolume;
});



// Configura√ß√£o do Canvas
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Bumpers laterais que invertem dire√ß√£o (declara√ß√£o inicial)
let bumpers = [
    {
        x: 40,
        y: 200,
        radius: 25,
        color: '#FFD700'
    },
    {
        x: 560,
        y: 200,
        radius: 25,
        color: '#FFD700'
    }
];

// Launcher (plunger) - bola pode entrar aqui e ser lan√ßada com Espa√ßo
let launcher = {
    x: canvas.width - 40,
    y: canvas.height - 60,
    width: 32,
    height: 56,
    color: '#00FFFF',
    inUse: false
};

// Configura√ß√£o responsiva do canvas
function resizeCanvas() {
    const container = document.querySelector('.game-container');
    const maxWidth = Math.min(700, window.innerWidth - 40);
    const maxHeight = window.innerHeight * 0.7;
    
    canvas.width = maxWidth;
    canvas.height = Math.min(maxHeight, maxWidth * 1.5);
    
    // Atualizar posi√ß√£o dos bumpers (altura intermedi√°ria)
    bumpers[0].x = 40;
    bumpers[0].y = canvas.height * 0.55;
    bumpers[1].x = canvas.width - 40;
    bumpers[1].y = canvas.height * 0.55;

    // Atualizar posi√ß√£o do launcher
    if (typeof launcher !== 'undefined') {
        launcher.x = canvas.width - 40;
        launcher.y = canvas.height - 60;
    }
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Estado do jogo
let gameState = {
    score: 0,
    balls: 3,
    highScore: localStorage.getItem('highScore') || 0,
    gameActive: false,
    currentLanguage: 'pt',

};

// Bola (caveira em chamas)
let ball = {
    x: canvas.width * 0.5,
    y: canvas.height * 0.75,
    radius: 12,
    vx: 0,
    vy: 0,
    launched: false
};

// Flippers
let leftFlipper = {
    x: canvas.width * 0.25,
    y: canvas.height - 50,
    width: 80,
    height: 15,
    angle: -0.3,
    targetAngle: -0.3,
    active: false
};

let rightFlipper = {
    x: canvas.width * 0.75,
    y: canvas.height - 50,
    width: 80,
    height: 15,
    angle: 0.3,
    targetAngle: 0.3,
    active: false
};

let centerFlipper = {
    x: canvas.width * 0.5,
    y: canvas.height - 80,
    width: 70,
    height: 15,
    angle: 0,
    targetAngle: 0,
    active: false
};

// Alvos
let targets = [];
function createTargets() {
    targets = [];
    const rows = 3;
    const cols = 5;
    const spacing = canvas.width / (cols + 1);
    
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            targets.push({
                x: spacing * (col + 1),
                y: 100 + row * 60,
                radius: 20,
                hit: false,
                hitTimer: 0,
                points: (rows - row) * 100
            });
        }
    }
}

createTargets();

// t√∫nel removido (feature deletada)


// Detec√ß√£o autom√°tica de idioma
function detectLanguage() {
    const userLang = navigator.language || navigator.userLanguage;
    const langCode = userLang.split('-')[0];
    
    if (translations[langCode]) {
        return langCode;
    }
    return 'en'; // Padr√£o para ingl√™s
}

// Aplicar tradu√ß√£o
function applyTranslation(lang) {
    gameState.currentLanguage = lang;
    const t = translations[lang];
    
    document.getElementById('title').textContent = t.title;
    document.getElementById('scoreLabel').textContent = t.scoreLabel;
    document.getElementById('ballsLabel').textContent = t.ballsLabel;
    document.getElementById('highScoreLabel').textContent = t.highScoreLabel;
    document.getElementById('leftFlipperLabel').textContent = t.leftFlipperLabel;
    document.getElementById('centerFlipperLabel').textContent = t.centerFlipperLabel;
    document.getElementById('rightFlipperLabel').textContent = t.rightFlipperLabel;
    document.getElementById('startLabel').textContent = t.startLabel;
    document.getElementById('instructionsTitle').textContent = t.instructionsTitle;
    document.getElementById('inst1').textContent = t.inst1;
    document.getElementById('inst2').textContent = t.inst2;
    document.getElementById('inst3').textContent = t.inst3;
    document.getElementById('inst4').textContent = t.inst4;
    document.getElementById('inst5').textContent = t.inst5;
    document.getElementById('inst6').textContent = t.inst6;
    document.getElementById('inst7').textContent = t.inst7;
    document.getElementById('inst8').textContent = t.inst8;
    document.getElementById('volumeLabel').textContent = t.volumeLabel;
}

// Inicializar idioma
const detectedLang = detectLanguage();
document.getElementById('languageSelect').value = detectedLang;
applyTranslation(detectedLang);

// Event listener para mudan√ßa de idioma
document.getElementById('languageSelect').addEventListener('change', (e) => {
    applyTranslation(e.target.value);
});

// Atualizar UI
function updateUI() {
    document.getElementById('scoreValue').textContent = gameState.score;
    document.getElementById('ballsValue').textContent = gameState.balls;
    document.getElementById('highScoreValue').textContent = gameState.highScore;
}

// Desenhar caveira em chamas
function drawSkullBall(x, y, radius) {
    // Chamas ao redor
    const flameCount = 8;
    for (let i = 0; i < flameCount; i++) {
        const angle = (Math.PI * 2 * i) / flameCount + Date.now() * 0.005;
        const flameX = x + Math.cos(angle) * radius * 1.2;
        const flameY = y + Math.sin(angle) * radius * 1.2;
        
        const gradient = ctx.createRadialGradient(flameX, flameY, 0, flameX, flameY, radius * 0.5);
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(flameX, flameY, radius * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Caveira
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    
    // Cabe√ßa da caveira
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Olhos
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(x - radius * 0.3, y - radius * 0.2, radius * 0.25, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(x + radius * 0.3, y - radius * 0.2, radius * 0.25, 0, Math.PI * 2);
    ctx.fill();
    
    // Nariz
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - radius * 0.15, y + radius * 0.2);
    ctx.lineTo(x + radius * 0.15, y + radius * 0.2);
    ctx.closePath();
    ctx.fill();
    
    // Boca/dentes
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 1.5;
    for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.moveTo(x + i * radius * 0.2, y + radius * 0.4);
        ctx.lineTo(x + i * radius * 0.2, y + radius * 0.7);
        ctx.stroke();
    }
    
    // Brilho neon vermelho
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 20;
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;
}

// Desenhar flipper
function drawFlipper(flipper, isLeft) {
    ctx.save();
    ctx.translate(flipper.x, flipper.y);
    ctx.rotate(flipper.angle);
    
    // Gradiente neon
    const gradient = ctx.createLinearGradient(-flipper.width/2, 0, flipper.width/2, 0);
    gradient.addColorStop(0, '#ff0000');
    gradient.addColorStop(0.5, '#ff3333');
    gradient.addColorStop(1, '#ff0000');
    
    ctx.fillStyle = gradient;
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 15;
    
    ctx.beginPath();
    ctx.roundRect(-flipper.width/2, -flipper.height/2, flipper.width, flipper.height, 7);
    ctx.fill();
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Desenhar alvo
function drawTarget(target) {
    const gradient = ctx.createRadialGradient(target.x, target.y, 0, target.x, target.y, target.radius);
    gradient.addColorStop(0, '#b44bff');
    gradient.addColorStop(0.5, '#7a22d1');
    gradient.addColorStop(1, '#4b0082');
    
    ctx.fillStyle = gradient;
    ctx.strokeStyle = '#b44bff';
    ctx.lineWidth = 2;
    
    ctx.shadowColor = '#b44bff';
    ctx.shadowBlur = 20;
    
    ctx.beginPath();
    ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Pontos no centro
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 12px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(target.points, target.x, target.y);

    // Mini anima√ß√£o ao acertar (pulso neon)
    if (target.hitTimer && target.hitTimer > 0) {
        const pulse = 1 + (target.hitTimer / 12) * 0.6;
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#ff4d4d';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(target.x, target.y, target.radius * pulse, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    ctx.shadowBlur = 0;
}

// Desenhar bumpers
function drawBumper(bumper) {
    const gradient = ctx.createRadialGradient(bumper.x, bumper.y, 0, bumper.x, bumper.y, bumper.radius);
    gradient.addColorStop(0, '#FFFF00');
    gradient.addColorStop(0.5, bumper.color);
    gradient.addColorStop(1, '#FF8C00');
    
    ctx.fillStyle = gradient;
    ctx.strokeStyle = bumper.color;
    ctx.lineWidth = 3;
    
    ctx.shadowColor = bumper.color;
    ctx.shadowBlur = 25;
    
    ctx.beginPath();
    ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Desenhar seta indicando invers√£o
    ctx.fillStyle = '#000';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('‚Üî', bumper.x, bumper.y);
    
    ctx.shadowBlur = 0;
}

// F√≠sica do jogo
// Desenhar t√∫nel (entrada e sa√≠da)

function updatePhysics() {
    if (!gameState.gameActive) return;
    
    // Gravidade
    ball.vy += 0.20;
    
    // Atualizar posi√ß√£o
    ball.x += ball.vx;
    ball.y += ball.vy;
    
    // Colis√£o com paredes
    if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
        ball.vx *= -0.8;
        ball.x = ball.x < canvas.width / 2 ? ball.radius : canvas.width - ball.radius;
        playSound('wall');
    }
    
    if (ball.y - ball.radius < 0) {
        ball.vy *= -0.8;
        ball.y = ball.radius;
        playSound('wall');
    }
    

    // Perder a bola
    if (ball.y > canvas.height + ball.radius) {
        playSound('lose');
        gameState.balls--;
        if (gameState.balls > 0) {
            resetBall();
        } else {
            endGame();
        }
        updateUI();
    }
    
    // Colis√£o com alvos
    targets.forEach(target => {
        const dx = ball.x - target.x;
        const dy = ball.y - target.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < ball.radius + target.radius) {
            if (!target.hitTimer || target.hitTimer <= 0) {
                gameState.score += target.points;
                updateUI();
                playSound('hit');
                target.hitTimer = 12;
            }
            
            // Desviar trajet√≥ria com impulso
            const angle = Math.atan2(dy, dx);
            const speed = Math.max(8.5, Math.hypot(ball.vx, ball.vy));
            const jitter = (Math.random() - 0.5) * 0.5;
            ball.vx = Math.cos(angle + jitter) * speed;
            ball.vy = Math.sin(angle + jitter) * speed;
            
            // Afastar a bola do alvo para evitar m√∫ltiplos hits cont√≠nuos
            ball.x = target.x + Math.cos(angle) * (ball.radius + target.radius + 2);
            ball.y = target.y + Math.sin(angle) * (ball.radius + target.radius + 2);
        }
    });
    
    // Atualizar anima√ß√£o dos alvos
    targets.forEach(target => {
        if (target.hitTimer && target.hitTimer > 0) {
            target.hitTimer -= 1;
        }
    });

    // Colis√£o com bumpers (invertem dire√ß√£o horizontal)
    bumpers.forEach(bumper => {
        const dx = ball.x - bumper.x;
        const dy = ball.y - bumper.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < ball.radius + bumper.radius) {
            // Inverter dire√ß√£o horizontal
            ball.vx *= -1.0;
            // Manter ou amplificar dire√ß√£o vertical
            ball.vy *= 1.0;
            
            // Afastar a bola do bumper
            const angle = Math.atan2(dy, dx);
            ball.x = bumper.x + Math.cos(angle) * (ball.radius + bumper.radius + 2);
            ball.y = bumper.y + Math.sin(angle) * (ball.radius + bumper.radius + 2);
            
            gameState.score += 50;
            updateUI();
            playSound('hit');
        }
    });

    // Capturar a bola no launcher se ela entrar na √°rea inferior e estiver descendo
    if (typeof launcher !== 'undefined' && !ball.inLauncher && ball.vy > 0) {
        const lx = launcher.x;
        const ly = launcher.y;
        const left = lx - launcher.width/2;
        const right = lx + launcher.width/2;
        const top = ly - launcher.height/2;
        const bottom = ly + launcher.height/2;
        if (ball.x > left && ball.x < right && (ball.y + ball.radius) > top && (ball.y - ball.radius) < bottom) {
            // Capturar
            ball.inLauncher = true;
            ball.vx = 0;
            ball.vy = 0;
            ball.x = lx;
            ball.y = top - ball.radius + 2;
            playSound('launch');
        }
    }

    // Se a bola estiver no launcher, mant√™-la fixada na posi√ß√£o
    if (ball.inLauncher) {
        ball.x = launcher.x;
        ball.y = launcher.y - launcher.height/2 - ball.radius + 2;
    }
    
    // Colis√£o com flippers
    checkFlipperCollision(leftFlipper);
    checkFlipperCollision(rightFlipper);
    checkFlipperCollision(centerFlipper);
    
    // Atualizar √¢ngulos dos flippers
    leftFlipper.angle += (leftFlipper.targetAngle - leftFlipper.angle) * 0.2;
    rightFlipper.angle += (rightFlipper.targetAngle - rightFlipper.angle) * 0.2;
    centerFlipper.angle += (centerFlipper.targetAngle - centerFlipper.angle) * 0.2;



}

function checkFlipperCollision(flipper) {
    const dx = ball.x - flipper.x;
    const dy = ball.y - flipper.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < ball.radius + flipper.height && 
        Math.abs(dx) < flipper.width / 2 && 
        Math.abs(dy) < flipper.height * 2) {
        
        ball.vy = -10.5;
        ball.vx += (ball.x - flipper.x) * 0.25;
        ball.y = flipper.y - ball.radius - flipper.height;
        playSound('flipper');
    }
}

// Desenhar launcher (plunger)
function drawLauncher() {
    const lx = launcher.x;
    const ly = launcher.y;
    ctx.save();
    ctx.fillStyle = launcher.color;
    ctx.strokeStyle = '#003333';
    ctx.lineWidth = 2;
    // corpo do launcher
    ctx.beginPath();
    ctx.roundRect(lx - launcher.width/2, ly - launcher.height/2, launcher.width, launcher.height, 6);
    ctx.fill();
    ctx.stroke();

    // indicador de instru√ß√£o
    if (ball.inLauncher) {
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Press SPACE to launch', lx, ly - launcher.height/2 - 10);
    }
    ctx.restore();

// Resetar bola
function resetBall() {
    ball.x = canvas.width * 0.5;
    ball.y = canvas.height * 0.75;
    ball.vx = 0;
    ball.vy = 0;
    ball.launched = false;
    ball.inLauncher = false;
}


// Iniciar jogo
function startGame() {
    gameState.score = 0;
    gameState.balls = 3;
    gameState.gameActive = true;
    createTargets();
    resetBall();
    updateUI();
    
    // Iniciar m√∫sica de fundo
    if (backgroundMusic.paused) {
        backgroundMusic.play().catch(e => console.log('√Åudio bloqueado pelo navegador'));
    }
}

// Finalizar jogo
function endGame() {
    gameState.gameActive = false;
    
    // Pausar m√∫sica de fundo
    backgroundMusic.pause();
    
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('highScore', gameState.highScore);
        playSound('highScore');
        setTimeout(() => {
            alert(translations[gameState.currentLanguage].newHighScore);
        }, 800);
    } else {
        playSound('gameOver');
    }
    
    updateUI();
    setTimeout(() => {
        alert(translations[gameState.currentLanguage].gameOver + '\n' + 
              translations[gameState.currentLanguage].scoreLabel + ': ' + gameState.score);
    }, gameState.score > gameState.highScore ? 1000 : 800);
}

// Loop de renderiza√ß√£o
function render() {
    // Limpar canvas
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Desenhar alvos
    targets.forEach(drawTarget);
    
    // Desenhar bumpers
    bumpers.forEach(drawBumper);
    
    // Desenhar flippers
    drawFlipper(leftFlipper, true);
    drawFlipper(rightFlipper, false);
    drawFlipper(centerFlipper, false);

    // Desenhar launcher
    if (typeof launcher !== 'undefined') {
        drawLauncher();
    }    

    // Desenhar bola (se estiver subindo, manter vis√≠vel)
    drawSkullBall(ball.x, ball.y, ball.radius);
    
    // Atualizar f√≠sica
    updatePhysics();
    
    requestAnimationFrame(render);
}

// Ativar √°udio no primeiro clique (necess√°rio para navegadores)
document.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    // Tentar reproduzir m√∫sica de fundo se o jogo estiver ativo
    if (gameState.gameActive && backgroundMusic.paused) {
        backgroundMusic.play().catch(e => console.log('√Åudio bloqueado'));
    }
}, { once: true });

// Controles de teclado
document.addEventListener('keydown', (e) => {
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    if (e.code === 'ArrowLeft') {
        leftFlipper.targetAngle = -0.8;
        leftFlipper.active = true;
        playSound('flipper');
    }
    if (e.code === 'ArrowRight') {
        rightFlipper.targetAngle = 0.8;
        rightFlipper.active = true;
        playSound('flipper');
    }
    if (e.code === 'ArrowDown') {
        e.preventDefault();
        centerFlipper.targetAngle = -0.6;
        centerFlipper.active = true;
        playSound('flipper');
    }

    // Espa√ßo: lan√ßar a bola se estiver no launcher
    if (e.code === 'Space') {
        if (gameState.gameActive && ball.inLauncher) {
            e.preventDefault();
            ball.inLauncher = false;
            ball.launched = true;
            ball.vy = -10.5;
            ball.vx = (Math.random() - 0.5) * 2.5;
            playSound('launch');
        }
    }

});

document.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') {
        leftFlipper.targetAngle = -0.3;
        leftFlipper.active = false;
    }
    if (e.code === 'ArrowRight') {
        rightFlipper.targetAngle = 0.3;
        rightFlipper.active = false;
    }
    if (e.code === 'ArrowDown') {
        centerFlipper.targetAngle = 0;
        centerFlipper.active = false;
    }
});

// Controles de toque/mouse
const leftBtn = document.getElementById('leftFlipper');
const centerBtn = document.getElementById('centerFlipper');
const rightBtn = document.getElementById('rightFlipper');
const startBtn = document.getElementById('startBtn');

leftBtn.addEventListener('mousedown', () => {
    leftFlipper.targetAngle = -0.8;
});
leftBtn.addEventListener('mouseup', () => {
    leftFlipper.targetAngle = -0.3;
});
leftBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    leftFlipper.targetAngle = -0.8;
});
leftBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    leftFlipper.targetAngle = -0.3;
});

centerBtn.addEventListener('mousedown', () => {
    centerFlipper.targetAngle = -0.6;
});
centerBtn.addEventListener('mouseup', () => {
    centerFlipper.targetAngle = 0;
});
centerBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    centerFlipper.targetAngle = -0.6;
});
centerBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    centerFlipper.targetAngle = 0;
});

rightBtn.addEventListener('mousedown', () => {
    rightFlipper.targetAngle = 0.8;
});
rightBtn.addEventListener('mouseup', () => {
    rightFlipper.targetAngle = 0.3;
});
rightBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    rightFlipper.targetAngle = 0.8;
});
rightBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    rightFlipper.targetAngle = 0.3;
});

startBtn.addEventListener('click', () => {
    if (!gameState.gameActive) {
        startGame();
    }
});

// Inicializar
updateUI();
render();
